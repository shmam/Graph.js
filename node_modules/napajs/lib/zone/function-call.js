"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var transport = require("../transport");
/// <summary> Rejection type </summary>
/// TODO: we need a better mapping between error code and result code.
var RejectionType;
(function (RejectionType) {
    RejectionType[RejectionType["TIMEOUT"] = 3] = "TIMEOUT";
    RejectionType[RejectionType["APP_ERROR"] = 6] = "APP_ERROR";
})(RejectionType = exports.RejectionType || (exports.RejectionType = {}));
/// <summary> 
///     Proxy function for __napa_zone_call__. 
///     1) calling a global function: 
///        module name: undefined or empty string
///        function name: global function name
///     2) calling an anonymous function at client side: 
///        module name: literal '__function' 
///        function name: hash returned from transport.saveFunction().
///     3) calling a function from a module:
///        module name: target module path.
///        function name: target function name from the module.
///
///     function name can have multiple levels like 'foo.bar'.
/// </summary>
function call(context) {
    // Cache the context since every call to context.transportContext will create a new wrap upon inner TransportContext pointer.
    var transportContext = context.transportContext;
    var result = undefined;
    try {
        result = callFunction(context.module, context.function, context.args, transportContext, context.options);
    }
    catch (error) {
        context.reject(error);
        return;
    }
    if (result != null
        && typeof result === 'object'
        && typeof result['then'] === 'function') {
        // Delay completion if return value is a promise.
        result.then(function (value) {
            finishCall(context, transportContext, value);
        })
            .catch(function (error) {
            context.reject(error);
        });
        return;
    }
    finishCall(context, transportContext, result);
}
exports.call = call;
/// <summary> Call a function. </summary>
function callFunction(moduleName, functionName, marshalledArgs, transportContext, options) {
    var module = null;
    var useAnonymousFunction = false;
    if (moduleName == null || moduleName.length === 0 || moduleName === 'global') {
        module = global;
    }
    else if (moduleName === '__function') {
        useAnonymousFunction = true;
    }
    else {
        module = require(moduleName);
    }
    var func = null;
    if (useAnonymousFunction) {
        func = transport.loadFunction(functionName);
    }
    else {
        if (module == null) {
            throw new Error("Cannot load module \"" + moduleName + "\".");
        }
        func = module;
        if (functionName != null && functionName.length != 0) {
            var path = functionName.split('.');
            for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
                var item = path_1[_i];
                func = func[item];
                if (func === undefined) {
                    throw new Error("Cannot find function '" + functionName + "' in module '" + moduleName + "'");
                }
            }
        }
        if (typeof func !== 'function') {
            throw new Error("'" + functionName + "' in module '" + moduleName + "' is not a function");
        }
    }
    var args = marshalledArgs.map(function (arg) { return transport.unmarshall(arg, transportContext); });
    return func.apply(this, args);
}
/// <summary> Finish call with result. </summary>
function finishCall(context, transportContext, result) {
    var payload = undefined;
    try {
        payload = transport.marshall(result, transportContext);
    }
    catch (error) {
        context.reject(error);
        return;
    }
    context.resolve(payload);
}
