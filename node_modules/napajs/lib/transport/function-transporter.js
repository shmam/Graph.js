"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
/// <summary> Function hash to function cache. </summary>
var _hashToFunctionCache = {};
/// <summary> Function to hash cache. </summary>
/// <remarks> Function cannot be used as a key in TypeScript. </remarks>
var _functionToHashCache = {};
/// <summary> Marshalled function body cache. </summary>
var _store;
/// <summary> Get underlying store to save marshall function body across isolates. </summary>
function getStore() {
    if (_store == null) {
        // Lazy creation function store
        // 1) avoid circular runtime dependency between store and transport.
        // 2) avoid unnecessary cost when function transport is not used.
        _store = require('../store/store-api')
            .getOrCreate('__napajs_marshalled_functions');
    }
    return _store;
}
/// <summary> Save function and get a hash string to use it later. </summary>
function save(func) {
    var hash = _functionToHashCache[(func)];
    if (hash == null) {
        // Should happen only on first marshall of input function in current isolate.
        var origin = func.origin || '';
        var body = func.toString();
        var fullContent = origin + ":" + body;
        hash = getFunctionHash(fullContent);
        var def = {
            origin: origin,
            body: body
        };
        getStore().set(hash, def);
        cacheFunction(hash, func);
    }
    return hash;
}
exports.save = save;
/// <summary> Load a function with a hash retrieved from `save`. </summary>
function load(hash) {
    var func = _hashToFunctionCache[hash];
    if (func == null) {
        // Should happen only on first unmarshall of given hash in current isolate..
        var def = getStore().get(hash);
        if (def == null) {
            throw new Error("Function hash cannot be found: " + hash);
        }
        func = loadFunction(def);
        cacheFunction(hash, func);
    }
    return func;
}
exports.load = load;
/// <summary> Cache function with its hash in current isolate. </summary>
function cacheFunction(hash, func) {
    _functionToHashCache[(func)] = hash;
    _hashToFunctionCache[hash] = func;
}
/// <summary> Generate hash for function definition using DJB2 algorithm. 
/// See: https://en.wikipedia.org/wiki/DJB2 
/// </summary>
function getFunctionHash(signature) {
    var hash = 5381;
    for (var i = 0; i < signature.length; ++i) {
        hash = (hash * 33) ^ signature.charCodeAt(i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
    * integers. Since we want the results to be always positive, convert the
    * signed int to an unsigned by doing an unsigned bitshift. */
    return (hash >>> 0).toString(16);
}
/// <summary> Load function from definition. </summary>
function loadFunction(def) {
    var moduleId = def.origin;
    var script = "module.exports = " + def.body + ";";
    var func = null;
    if (typeof __in_napa === 'undefined') {
        // In node, we create a sandbox using Module
        var Module = null;
        if (Module == null) {
            Module = require('module');
        }
        var module_1 = new Module(moduleId);
        module_1.filename = moduleId;
        module_1.paths = Module._nodeModulePaths(path.dirname(def.origin));
        module_1._compile(script, moduleId);
        func = module_1.exports;
    }
    else {
        // In napa, we create a sandbox using require(path, script);
        func = require(moduleId, script);
    }
    func.origin = def.origin;
    return func;
}
