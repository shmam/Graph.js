"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/// <summary> In Napa.JS, transporting objects across isolates is required for multi-thread collaborations.
/// 
/// A JavaScript value is transportable, if
/// 1) it is a built-in JavaScript types, which includes primitive types, plain objects (whose constructor name is 'Object') and arrays.
/// 2) or a class implements Transportable.
/// 3) or it is a composite of #1 and #2.
/// 
/// </summary>
var transport = require("./transport");
var v8 = require("../v8");
var path = require("path");
/// <summary> Abstract class for transportable objects. 
/// Subclass' obligations:
/// 1) Constructor should accept zero parameters .
/// 2) Implement save()/load() to marshall/unmarshall internal state.
/// 3) Register with transport with a Constructor ID (cid) via one of following methods:
///    - declare class decorator: @cid() use '<module-name>.<class-name>' as cid.
///    - declare class decorator: @cid('<guid>') use the specified GUID as cid.
/// </summary>
var TransportableObject = /** @class */ (function () {
    function TransportableObject() {
    }
    /// <summary> Get Constructor ID (cid) for this object. </summary>
    TransportableObject.prototype.cid = function () {
        return Object.getPrototypeOf(this).constructor._cid;
    };
    /// <summary> Marshall object into plain JavaScript object. </summary>
    /// <returns> Plain JavaScript value. </returns>
    TransportableObject.prototype.marshall = function (context) {
        var payload = {
            _cid: this.cid()
        };
        this.save(payload, context);
        return payload;
    };
    /// <summary> Unmarshall object from payload, which is a plain JavaScript value, and a transport context. </summary>
    /// <param name='payload'> Payload to read from, which already have inner objects transported. </param>
    /// <param name='context'> Transport context for looking up shared pointers. </param>
    TransportableObject.prototype.unmarshall = function (payload, context) {
        this.load(payload, context);
    };
    return TransportableObject;
}());
exports.TransportableObject = TransportableObject;
/// <summary> Base class for JavaScript class that is auto transportable. 
/// A JavaScript class can be auto transportable when 
/// 1) it has a default constructor.
/// 2) members are transportable types.
/// 3) register via class decorator @cid or transport.register.
/// </summary>
var AutoTransportable = /** @class */ (function (_super) {
    __extends(AutoTransportable, _super);
    function AutoTransportable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /// <summary> Automatically save own properties to payload. </summary>
    /// <param name='payload'> Plain JS object to write to. </param>
    /// <param name='context'> Transport context for saving shared pointers, only usable for C++ addons that extends napa::module::ShareableWrap. </param>
    AutoTransportable.prototype.save = function (payload, context) {
        for (var _i = 0, _a = Object.getOwnPropertyNames(this); _i < _a.length; _i++) {
            var property = _a[_i];
            (payload)[property] = transport.marshallTransform((this)[property], context);
        }
    };
    /// <summary> Automatically load own properties from payload. </summary>
    /// <param name='payload'> Payload to read from, which already have inner objects transported. </param>
    /// <param name='context'> Transport context for loading shared pointers, only usable for C++ addons that extends napa::module::ShareableWrap. </param>
    AutoTransportable.prototype.load = function (payload, context) {
        // Members have already been unmarshalled. Do nothing.
    };
    return AutoTransportable;
}(TransportableObject));
exports.AutoTransportable = AutoTransportable;
/// <summary> Tell if a jsValue is transportable. </summary>
function isTransportable(jsValue) {
    if (Array.isArray(jsValue)) {
        // Traverse array.
        for (var _i = 0, jsValue_1 = jsValue; _i < jsValue_1.length; _i++) {
            var element = jsValue_1[_i];
            if (!isTransportable(element)) {
                return false;
            }
        }
    }
    else if (typeof jsValue === 'object') {
        var constructor = Object.getPrototypeOf(jsValue).constructor;
        if (constructor.name === 'Object') {
            // Traverse object.
            for (var property in jsValue) {
                if (!isTransportable(jsValue[property])) {
                    return false;
                }
            }
        }
        else if (typeof jsValue['cid'] !== 'function') {
            return false;
        }
    }
    return true;
}
exports.isTransportable = isTransportable;
/// <summary> Decorator 'cid' to register a transportable class with a 'cid'. </summary>
/// <param name="guid"> If specified, use this GUID as cid. </param>
function cid(guid) {
    var moduleName = null;
    if (!guid) {
        moduleName = extractModuleName(v8.currentStack(2)[1].getFileName());
    }
    return function (constructor) {
        var cid = moduleName ? moduleName + "." + constructor.name : guid;
        constructor['_cid'] = cid;
        transport.register(constructor);
    };
}
exports.cid = cid;
var NODE_MODULE_PREFIX = 'node_modules/';
/// <summary> Extract module name from module.id.</summary>
function extractModuleName(moduleId) {
    moduleId = moduleId.replace('\\\\', '/');
    if (moduleId.endsWith('.js')) {
        moduleId = moduleId.substr(0, moduleId.length - 3);
    }
    var moduleRootStart = moduleId.lastIndexOf(NODE_MODULE_PREFIX);
    if (moduleRootStart >= 0) {
        // module is under node_modules.
        return moduleId.substr(moduleRootStart + NODE_MODULE_PREFIX.length);
    }
    else {
        // module is located using absolute or relative path.
        return path.relative(process.cwd(), moduleId).replace('\\\\', '/');
    }
}
