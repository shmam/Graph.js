"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
var napa = require("../lib/index");
var assert = require("assert");
var t = require("./napa-zone/test");
describe('napajs/transport', function () {
    var napaZone = napa.zone.create('zone10');
    describe('TransportContext', function () {
        var tc = napa.transport.createTransportContext();
        var allocator = napa.memory.debugAllocator(napa.memory.crtAllocator);
        it('#saveShared', function () {
            tc.saveShared(allocator);
        });
        var shareable = null;
        it('#loadShared', function () {
            shareable = tc.loadShared(allocator.handle);
            assert.deepEqual(shareable.handle, allocator.handle);
        });
        it('#sharedCount', function () {
            assert.equal(shareable.refCount, 3);
        });
    });
    describe('Transportable', function () {
        it('#IsTransportable', function () {
            assert(napa.transport.isTransportable(new t.CanPass(napa.memory.crtAllocator)));
            assert(napa.transport.isTransportable(1));
            assert(napa.transport.isTransportable('hello world'));
            assert(napa.transport.isTransportable([1, 2, 3]));
            assert(napa.transport.isTransportable([1, 2, new t.CanPass(napa.memory.crtAllocator)]));
            assert(napa.transport.isTransportable({ a: 1 }));
            assert(napa.transport.isTransportable({ a: 1, b: new t.CanPass(napa.memory.crtAllocator) }));
            assert(napa.transport.isTransportable(function () { return 0; }));
            assert(!napa.transport.isTransportable(new t.CannotPass()));
            assert(!napa.transport.isTransportable([1, new t.CannotPass()]));
            assert(!napa.transport.isTransportable({ a: 1, b: new t.CannotPass() }));
        });
    });
    describe('Marshall/Unmarshall', function () {
        it('@node: simple types', function () {
            t.simpleTypeTransportTest();
        });
        it('@napa: simple types', function () {
            napaZone.execute('./napa-zone/test', "simpleTypeTransportTest");
        }).timeout(3000);
        it('@node: JS transportable', function () {
            t.jsTransportTest();
        });
        it('@napa: JS transportable', function () {
            napaZone.execute('./napa-zone/test', "jsTransportTest");
        });
        it('@node: addon transportable', function () {
            t.addonTransportTest();
        });
        it('@napa: addon transportable', function () {
            napaZone.execute('./napa-zone/test', "addonTransportTest");
        });
        it('@node: function transportable', function () {
            t.functionTransportTest();
        });
        it('@napa: function transportable', function () {
            napaZone.execute('./napa-zone/test', "functionTransportTest");
        });
        it('@node: composite transportable', function () {
            t.compositeTransportTest();
        });
        it('@napa: composite transportable', function () {
            napaZone.execute('./napa-zone/test', "compositeTransportTest");
        });
        it('@node: non-transportable', function () {
            t.nontransportableTest();
        });
        it('@napa: non-transportable', function () {
            napaZone.execute('./napa-zone/test', "nontransportableTest");
        });
    });
    function transportBuiltinObjects() {
        var zoneId = 'transport-built-in-test-zone';
        var transportTestZone = napa.zone.create(zoneId, { workers: 4 });
        /// Construct an expected result string.
        /// constructExpectedResult(5, 5, 255, 0) returns '0,0,0,0,0'
        /// constructExpectedResult(2, 5, 255, 0) returns '0,0,255,255,255'
        /// constructExpectedResult(0, 5, 255, 0) returns '255,255,255,255,255'
        function constructExpectedResult(i, size, expectedValue, defaultValue) {
            if (defaultValue === void 0) { defaultValue = 0; }
            var assert = require('assert');
            assert(i >= 0 && size >= i);
            var expected = '';
            for (var t_1 = 0; t_1 < i; t_1++) {
                if (t_1 > 0)
                    expected += ',';
                expected += defaultValue.toString();
            }
            for (var t = i; t < size; t++) {
                if (t > 0)
                    expected += ',';
                expected += expectedValue.toString();
            }
            return expected;
        }
        global.constructExpectedResult = constructExpectedResult;
        transportTestZone.broadcast("global.constructExpectedResult = " + constructExpectedResult.toString());
        it('@node: transport SharedArrayBuffer (SAB)', function () {
            var promises = [];
            var sab = new SharedArrayBuffer(4);
            for (var i = 0; i < 4; i++) {
                promises[i] = transportTestZone.execute(function (sab, i) {
                    var ta = new Uint8Array(sab);
                    ta[i] = 100;
                }, [sab, i]);
            }
            return Promise.all(promises).then(function (values) {
                var ta = new Uint8Array(sab);
                assert.deepEqual(ta.toString(), '100,100,100,100');
            });
        });
        it('@node: transport composite object of SharedArrayBuffer', function () {
            var sab = new SharedArrayBuffer(4);
            var ta1 = new Uint8Array(sab);
            var ta2 = new Uint8Array(sab);
            var obj = { sab: sab, tas: { ta1: ta1, ta2: ta2 }, ta22: ta2 };
            return transportTestZone.execute(function (obj) {
                var ta = new Uint8Array(obj.sab);
                ta[0] = 99;
                obj.tas.ta1[1] = 88;
                obj.tas.ta2[2] = 77;
                obj.ta22[3] = 66;
            }, [obj]).then(function (result) {
                var ta_sab = new Uint8Array(sab);
                assert.deepEqual(ta_sab.toString(), '99,88,77,66');
            });
        });
        function recursivelySetElementOfSharedArrayBuffer(zoneId, sab, i, value) {
            if (i < 0)
                return;
            var ta = new Uint8Array(sab);
            ta[i] = value;
            var assert = require('assert');
            // SharedArrayBuffer shares storage when it is transported,
            // so elements with index > i have been set to {value} by those finished zone.executions.
            var expected = global.constructExpectedResult(i, ta.length, value);
            assert.equal(ta.toString(), expected);
            var napa = require('../lib/index');
            var zone = (i % 4 < 2) ? napa.zone.get(zoneId) : napa.zone.node;
            zone.execute(recursivelySetElementOfSharedArrayBuffer, [zoneId, sab, i - 1, value]).then(function (result) {
                // SharedArrayBuffer shares storage when it is transported,
                // if i > 0, ta[i - 1] has been set to {value} by the previous zone.execute,
                // so ta.toString() should be larger than {expected} constructed before.
                if (i > 0)
                    assert(ta.toString() > expected);
                else if (i === 0)
                    assert.equal(ta.toString(), expected);
                else
                    assert(false);
            });
        }
        // @node: node -> napa -> napa -> node -> node -> napa -> napa
        it('@node: recursively transport received SharedArrayBuffer (SAB)', function () {
            var size = 8;
            var timeout = 50;
            var value = 255;
            var sab = new SharedArrayBuffer(size);
            var ta = new Uint8Array(sab);
            recursivelySetElementOfSharedArrayBuffer(zoneId, sab, size - 1, value);
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // Because SharedArrayBuffer will share storage when it is transported,
                    // once the recursive process finished, all elements of
                    // the original TypeArray (based on SharedArrayBuffer) should have been set to {value}.
                    var expected = global.constructExpectedResult(0, ta.length, value);
                    assert.equal(ta.toString(), expected);
                    resolve();
                }, timeout);
            });
        });
        function recursivelySetElementOfTypedArray_SAB(zoneId, ta, i, value) {
            if (i < 0)
                return;
            ta[i] = value;
            var assert = require('assert');
            // SharedArrayBuffer shares storage when it is transported,
            // so elements with index > i have been set to {value} by those finished zone.executions.
            var expected = global.constructExpectedResult(i, ta.length, value);
            assert.equal(ta.toString(), expected);
            var napa = require('../lib/index');
            var zone = (i % 4 < 2) ? napa.zone.get(zoneId) : napa.zone.node;
            zone.execute(recursivelySetElementOfTypedArray_SAB, [zoneId, ta, i - 1, value]).then(function (result) {
                // SharedArrayBuffer shares storage when it is transported,
                // if i > 0, ta[i - 1] has been set to {value} by the previous zone.execute,
                // so ta.toString() should be larger than {expected} constructed before.
                if (i > 0)
                    assert(ta.toString() > expected);
                else if (i === 0)
                    assert.equal(ta.toString(), expected);
                else
                    assert(false);
            });
        }
        // @node: node -> napa -> napa -> node -> node -> napa -> napa
        it('@node: recursively transport received TypedArray based on SAB', function () {
            var size = 8;
            var timeout = 50;
            var value = 255;
            var sab = new SharedArrayBuffer(size);
            var ta = new Uint8Array(sab);
            recursivelySetElementOfTypedArray_SAB(zoneId, ta, size - 1, value);
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // Because SharedArrayBuffer will share storage when it is transported,
                    // once the recursive process finished, all elements of
                    // the original TypeArray (based on SharedArrayBuffer) should have been set to {value}.
                    var expected = global.constructExpectedResult(0, ta.length, value);
                    assert.equal(ta.toString(), expected);
                    resolve();
                }, timeout);
            });
        });
        function recursivelySetElementOfArrayBuffer(zoneId, ab, i, value) {
            if (i < 0) {
                return;
            }
            var ta = new Uint8Array(ab);
            ta[i] = value;
            var assert = require('assert');
            // ArrayBuffer's storage will be copied when it is transported.
            // Elements with index > i should all be {value}.
            // They are copied from the previous zone.execution.
            var expected = global.constructExpectedResult(i, ta.length, value);
            assert.equal(ta.toString(), expected);
            var napa = require('../lib/index');
            var zone = (i % 4 < 2) ? napa.zone.get(zoneId) : napa.zone.node;
            zone.execute(recursivelySetElementOfArrayBuffer, [zoneId, ab, i - 1, value]).then(function (result) {
                // The original TypeArray (based on ArrayBuffer) shouldn't been changed by the just-finished zone.execute.
                assert.equal(ta.toString(), expected);
            });
        }
        // @node: node -> napa -> napa -> node -> node -> napa -> napa
        it('@node: recursively transport received ArrayBuffer (AB)', function () {
            var size = 8;
            var timeout = 50;
            var value = 255;
            var ab = new ArrayBuffer(size);
            var ta = new Uint8Array(ab);
            recursivelySetElementOfArrayBuffer(zoneId, ab, size - 1, value);
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // Except ta[ta-length -1] was set to {value} before the 1st transportation,
                    // the original TypeArray (based on ArrayBuffer) shouldn't been changed by the recursive execution.
                    var expected = global.constructExpectedResult(ta.length - 1, ta.length, value);
                    assert.equal(ta.toString(), expected);
                    resolve();
                }, timeout);
            });
        });
        function recursivelySetElementOfTypeArray_AB(zoneId, ta, i, value) {
            if (i < 0) {
                return;
            }
            ta[i] = value;
            var assert = require('assert');
            // ArrayBuffer's storage will be copied when it is transported.
            // Elements with index > i should all be {value}.
            // They are copied from the previous zone.execution.
            var expected = global.constructExpectedResult(i, ta.length, value);
            assert.equal(ta.toString(), expected);
            var napa = require('../lib/index');
            var zone = (i % 4 < 2) ? napa.zone.get(zoneId) : napa.zone.node;
            zone.execute(recursivelySetElementOfTypeArray_AB, [zoneId, ta, i - 1, value]).then(function (result) {
                // The original TypeArray (based on ArrayBuffer) shouldn't been changed by the just-finished zone.execute.
                assert.equal(ta.toString(), expected);
            });
        }
        // @node: node -> napa -> napa -> node -> node -> napa -> napa
        it('@node: recursively transport received TypedArray based on AB', function () {
            var size = 8;
            var timeout = 50;
            var value = 255;
            var ab = new ArrayBuffer(size);
            var ta = new Uint8Array(ab);
            recursivelySetElementOfTypeArray_AB(zoneId, ta, size - 1, value);
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    // Except ta[ta-length -1] was set to {value} before the 1st transportation,
                    // the original TypeArray (based on ArrayBuffer) shouldn't been changed by the recursive execution.
                    var expected = global.constructExpectedResult(ta.length - 1, ta.length, value);
                    assert.equal(ta.toString(), expected);
                    resolve();
                }, timeout);
            });
        });
    }
    var builtinTestGroup = 'Transport built-in objects';
    var nodeVersionMajor = parseInt(process.versions.node.split('.')[0]);
    if (nodeVersionMajor >= 9) {
        describe(builtinTestGroup, transportBuiltinObjects);
    }
    else {
        describe.skip(builtinTestGroup, transportBuiltinObjects);
        require('npmlog').warn(builtinTestGroup, 'This test group is skipped since it requires node v9.0.0 or above.');
    }
});
