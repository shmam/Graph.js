"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var assert = require("assert");
var napa = require("../../lib/index");
function bar(input) {
    return input;
}
exports.bar = bar;
var ns1;
(function (ns1) {
    var ns2;
    (function (ns2) {
        function foo(input) {
            return input;
        }
        ns2.foo = foo;
    })(ns2 = ns1.ns2 || (ns1.ns2 = {}));
})(ns1 = exports.ns1 || (exports.ns1 = {}));
function getCurrentZone() {
    return napa.zone.current;
}
exports.getCurrentZone = getCurrentZone;
function broadcast(id, code) {
    var zone = napa.zone.get(id);
    return zone.broadcast(code);
}
exports.broadcast = broadcast;
function broadcastTestFunction(id) {
    return napa.zone.get(id).broadcast(function (input) {
        console.log(input);
    }, ["hello world"]);
}
exports.broadcastTestFunction = broadcastTestFunction;
function broadcastTransportable(id) {
    return napa.zone.get(id).broadcast(function (input) {
        console.log(input);
    }, [napa.memory.crtAllocator]);
}
exports.broadcastTransportable = broadcastTransportable;
function broadcastClosure(id) {
    var zone = napa.zone.get(id);
    return zone.broadcast(function () {
        console.log(zone);
    }, []);
}
exports.broadcastClosure = broadcastClosure;
function execute(id, moduleName, functionName, args) {
    var zone = napa.zone.get(id);
    return new Promise(function (resolve, reject) {
        zone.execute(moduleName, functionName, args)
            .then(function (result) { return resolve(result.value); })
            .catch(function (error) { return reject(error); });
    });
}
exports.execute = execute;
function executeTestFunction(id) {
    var zone = napa.zone.get(id);
    return new Promise(function (resolve, reject) {
        zone.execute(function (input) { return input; }, ['hello world'])
            .then(function (result) { return resolve(result.value); })
            .catch(function (error) { return reject(error); });
    });
}
exports.executeTestFunction = executeTestFunction;
function executeTestFunctionWithClosure(id) {
    var zone = napa.zone.get(id);
    return new Promise(function (resolve, reject) {
        zone.execute(function () { return zone; }, [])
            .then(function (result) { return resolve(result.value); })
            .catch(function (error) { return reject(error); });
    });
}
exports.executeTestFunctionWithClosure = executeTestFunctionWithClosure;
function waitMS(waitTimeInMS) {
    var start = new Date().getTime();
    var wait = 0;
    do {
        wait = new Date().getTime() - start;
    } while (wait < waitTimeInMS);
    return wait - waitTimeInMS;
}
exports.waitMS = waitMS;
function executeTestFunctionWithTimeout(id, waitTimeInMS, timeoutInMS) {
    timeoutInMS = timeoutInMS ? timeoutInMS : Number.MAX_SAFE_INTEGER;
    var zone = napa.zone.get(id);
    return new Promise(function (resolve, reject) {
        zone.execute(waitMS, [waitTimeInMS], { timeout: timeoutInMS })
            .then(function (result) { return resolve(result.value); })
            .catch(function (error) { return reject(error); });
    });
}
exports.executeTestFunctionWithTimeout = executeTestFunctionWithTimeout;
function executeWithTransportableArgs(id) {
    var zone = napa.zone.get(id);
    return new Promise(function (resolve, reject) {
        zone.execute(function (allocator) {
            var assert = require("assert");
            assert.deepEqual(allocator.handle, global.napa.memory.crtAllocator.handle);
            return 1;
        }, [napa.memory.crtAllocator])
            .then(function (result) { return resolve(result.value); })
            .catch(function (error) { return reject(error); });
    });
}
exports.executeWithTransportableArgs = executeWithTransportableArgs;
function executeWithTransportableReturns(id) {
    var zone = napa.zone.get(id);
    return new Promise(function (resolve, reject) {
        zone.execute(function (allocator) {
            return allocator;
        }, [napa.memory.crtAllocator])
            .then(function (result) { return resolve(result.value); })
            .catch(function (error) { return reject(error); });
    });
}
exports.executeWithTransportableReturns = executeWithTransportableReturns;
/// <summary> Memory test helpers. </summary>
function crtAllocatorTest() {
    var handle = napa.memory.crtAllocator.allocate(10);
    assert(!napa.memory.isEmpty(handle));
    napa.memory.crtAllocator.deallocate(handle, 10);
}
exports.crtAllocatorTest = crtAllocatorTest;
function defaultAllocatorTest() {
    var handle = napa.memory.defaultAllocator.allocate(10);
    assert(!napa.memory.isEmpty(handle));
    napa.memory.defaultAllocator.deallocate(handle, 10);
}
exports.defaultAllocatorTest = defaultAllocatorTest;
function debugAllocatorTest() {
    var allocator = napa.memory.debugAllocator(napa.memory.defaultAllocator);
    var handle = allocator.allocate(10);
    assert(!napa.memory.isEmpty(handle));
    allocator.deallocate(handle, 10);
    var debugInfo = JSON.parse(allocator.getDebugInfo());
    assert.deepEqual(debugInfo, {
        allocate: 1,
        allocatedSize: 10,
        deallocate: 1,
        deallocatedSize: 10
    });
}
exports.debugAllocatorTest = debugAllocatorTest;
var store2 = null;
function getOrCreateStoreTest() {
    store2 = napa.store.getOrCreate('store2');
    assert(store2 != null);
    assert.equal(store2.id, 'store2');
    assert.equal(store2.size, 0);
}
exports.getOrCreateStoreTest = getOrCreateStoreTest;
function getStoreTest() {
    var store = napa.store.get('store2');
    assert.equal(store.id, 'store2');
    // Store created from node zone.
    var store1 = napa.store.get('store1');
    assert.equal(store1.id, 'store1');
}
exports.getStoreTest = getStoreTest;
function storeVerifyGet(storeId, key, expectedValue) {
    var store = napa.store.get(storeId);
    assert.deepEqual(store.get(key), expectedValue);
}
exports.storeVerifyGet = storeVerifyGet;
function storeGetCompareHandle(storeId, key, expectedHandle) {
    var store = napa.store.get(storeId);
    assert.deepEqual(store.get(key).handle, expectedHandle);
}
exports.storeGetCompareHandle = storeGetCompareHandle;
function storeSet(storeId, key, expectedValue) {
    var store = napa.store.get(storeId);
    store.set(key, expectedValue);
}
exports.storeSet = storeSet;
function storeDelete(storeId, key) {
    var store = napa.store.get(storeId);
    store.delete(key);
}
exports.storeDelete = storeDelete;
function storeVerifyNotExist(storeId, key) {
    var store = napa.store.get(storeId);
    assert(!store.has(key));
    assert(store.get(key) === undefined);
}
exports.storeVerifyNotExist = storeVerifyNotExist;
/// <summary> Transport test helpers. </summary>
var CannotPass = /** @class */ (function () {
    function CannotPass() {
    }
    return CannotPass;
}());
exports.CannotPass = CannotPass;
var CanPass = /** @class */ (function (_super) {
    __extends(CanPass, _super);
    function CanPass(allocator) {
        var _this = _super.call(this) || this;
        _this._allocator = allocator;
        return _this;
    }
    CanPass.prototype.save = function (payload, tc) {
        payload['_allocator'] = this._allocator.marshall(tc);
    };
    CanPass.prototype.load = function (payload, tc) {
        // Do nothing, as all members are transportable, which will be restored automatically.
    };
    CanPass = __decorate([
        napa.transport.cid()
    ], CanPass);
    return CanPass;
}(napa.transport.TransportableObject));
exports.CanPass = CanPass;
function testMarshallUnmarshall(input) {
    var tc = napa.transport.createTransportContext();
    var payload = napa.transport.marshall(input, tc);
    var expected = napa.transport.unmarshall(payload, tc);
    assert.equal(input.toString(), expected.toString());
}
function simpleTypeTransportTest() {
    testMarshallUnmarshall({
        a: 'hello',
        b: {
            c: [0, 1]
        }
    });
}
exports.simpleTypeTransportTest = simpleTypeTransportTest;
function jsTransportTest() {
    testMarshallUnmarshall(new CanPass(napa.memory.crtAllocator));
}
exports.jsTransportTest = jsTransportTest;
function functionTransportTest() {
    testMarshallUnmarshall(function () { return 0; });
}
exports.functionTransportTest = functionTransportTest;
function addonTransportTest() {
    testMarshallUnmarshall(napa.memory.debugAllocator(napa.memory.crtAllocator));
}
exports.addonTransportTest = addonTransportTest;
function compositeTransportTest() {
    testMarshallUnmarshall({
        a: napa.memory.debugAllocator(napa.memory.crtAllocator),
        b: [1, 2],
        c: {
            d: napa.memory.defaultAllocator,
            e: 1
        }
    });
}
exports.compositeTransportTest = compositeTransportTest;
function nontransportableTest() {
    var tc = napa.transport.createTransportContext();
    var input = new CannotPass();
    var success = false;
    try {
        napa.transport.marshall(input, tc);
        success = true;
    }
    catch (error) {
    }
    assert(!success);
}
exports.nontransportableTest = nontransportableTest;
